{
  "hash": "1ab9efd428ca99bff49baecbedc5abd0",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Pipes: a intuição matemática das funções compostas\"\ndescription: \"O operador pipe é um importante diferencial da programção em R, que torna o código mais legível e seu workflow mais produtivo.\"\ndate: \"2025-07-15\"\ncategories: [\"data-science\", \"R\"]\nimage: \"/static/images/blog/sigmund-pipes.jpg\"\nimage-alt: \"/static/images/blog/sigmund-pipes.jpg\"\n---\n\n\n\n# Pipes\n\n## Introdução\n\nA partir da versão 4.1.0, o `R` passou a oferecer o operador `|>` chamado de pipe (literalmente, *cano*)[^1]. Este operador foi fortemente inspirado no operador homônimo `%>%` do popular pacote `{magrittr}`.\n\n[^1]: Para a lista completa de mudanças veja [News and Notes](https://journal.r-project.org/archive/2021-1/core.pdf).\n\nNeste post, vamos explorar a intuição matemática do operador, usando funções compostas.\n\n## Funções compostas\n\nO operador pipe, essencialmente, **ordena uma função composta**.\n\nLembrando um pouco sobre funções compostas: a expressão abaixo mostra a aplicação de três funções onde primeiro aplica-se a função `f` sobre x, depois a função `g` e, por fim, a função `h`. Lê-se a função de dentro para fora.\n\n$$\nh(g(f(x))) = \\dots\n$$\n\nPara tornar o exemplo mais concreto considere o exemplo abaixo onde calcula-se a média geométrica de uma sequência de números aleatórios.\n\nA média geométrica é dada pela expressão:\n\n$$\n\\overline{x} = (\\prod_{i = 1}^{n}x_{i})^{\\frac{1}{n}} = \\text{exp}(\\frac{1}{n}\\sum_{i = 1}^{n}\\text{log}(x_{i}))\n$$\n\nA expressão acima é uma sequência de aplicação de funções sobre um vetor numérico $x$ :\n\n1.  Aplique a função $\\text{log}$ sobre todos os $x_{i}$.\n2.  Aplique a função \"somatório\", i.e., some todos os $\\text{log}(x_{i})$.\n3.  Divida a soma dos logs por $n$.\n4.  Aplique a função exponencial.\n\nNote que os passos 2 e 3 acima são equivalentes a calcular a média aritmética dos logs. Em termos de código, temos:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- rnorm(n = 100, mean = 10)\n#> Calcula a média geométrica\nexp(mean(log(x)))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 9.975\n```\n\n\n:::\n:::\n\n\n\nUsando a mesma notação acima, aplica-se primeiro a função `log` (f), depois a função `mean` (g) e, por fim, a função `exp` (h).\n\nUsando o operador pipe, pode-se reescrever a expressão da seguinte forma.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx |> log() |> mean() |> exp()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 9.975\n```\n\n\n:::\n:::\n\n\n\nNote que o resultado da função vai sendo \"carregado\" da esquerda para a direita sucessivamente.\n\nPara muitos usuários, a segunda sintaxe é mais intuitiva e fácil de ler. No segundo código a ordem em que o nome das funções aparecem coincide com a ordem da sua aplicação. No primeiro código temos que ler as funções de dentro para fora, indo da direita para a esquerda.\n\nNote que o uso de várias funções numa mesma linha de código também nos poupa de ter de criar objetos intermediários como no exemplo abaixo.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlog_x <- log(x)\nlog_media <- mean(log_x)\nmedia_geometrica_x <- exp(log_media)\n```\n:::\n\n\n\n### Detalhes\n\nOs exemplos acima funcionaram sem problemas porque usou-se o operador pipe para \"abrir\" uma função composta. O argumento de cada função subsequente é o resultado da função antecedente: funciona como uma linha de montagem, em que cada nova etapa soma-se ao resultado da etapa anterior.\n\nQuando o resultado da função anterior não vai diretamente no primeiro argumento da função subsequente, precisa-se usar o operador `_` (underscore). Este operador serve como um *placeholder*: indica onde que o resultado da etapa anterior deve entrar[^2]. No exemplo abaixo, uso o placeholder para colocar a base de dados filtrada no argumento `data` dentro da função `lm`.\n\n[^2]: Tecnicamente, o *placeholder* foi apenas introduzido na versão 4.2.0 como uma melhoria em relação ao pipe nativo implementado anteriormente. \"In a forward pipe `|>` expression it is now possible to use a named argument with the placeholder `_` in the `rhs` call to specify where the `lhs` is to be inserted. The placeholder can only appear once on the `rhs`.\". [Link original](https://cran.r-project.org/bin/windows/base/old/4.2.0/NEWS.R-4.2.0.html).\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncarros_4 <- subset(mtcars, cyl == 4)\nfit <- lm(mpg ~ wt, data = carros_4)\n\nmtcars |> \n  subset(cyl == 4) |> \n  lm(mpg ~ wt, data = _)\n```\n:::\n\n\n\nPor fim, temos o caso das funções anônimas[^3]. Uma função anônima é simplesmente uma função sem nome que é chamada uma única vez. Infelizmente, a sintaxe de um pipe com uma função anônima é bastante carregada.\n\n[^3]: A notação abaixo de função anônima, usando `\\(x)`, também foi introduzida na versão 4.1.0 do R. Antigamente, para se definir uma função era necessário usar `function(x)`.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nobjeto |> (\\(x, y, z, ...) {define função})()\n\n# Nova sintaxe de funções anônimas (similar a lambda no Python)\nobjeto |> (\\(x, y) {x^2 + y^2})()\n# Antiga sintaxe de funções anônimas\nobjeto |> (function(x, y) {x^2 + y^2})()\n```\n:::\n\n\n\nO exemplo repete o código acima, mas agora usa uma função anônima para pegar o R2 ajustado da regressão.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmtcars |> \n  subset(cyl == 4) |> \n  lm(mpg ~ wt, data = _) |> \n  (\\(x) {summary(x)$adj.r.squared})()\n```\n:::\n\n\n\n## Limitações\n\nImagine agora que se quer calcular o erro absoluto médio de uma regressão. Lembre-se que o EAM é dado por\n\n$$\n\\text{EAM} = \\frac{1}{N}\\sum_{i = 1}^{N}|e_{i}|\n$$\n\nonde $e_{i}$ é o resíduo da regressão. O código abaixo mostra como fazer isto usando pipes.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#> Estima uma regressão qualquer\nfit <- lm(mpg ~ wt, data = mtcars)\n\n#> Calcula o erro absoluto médio\nfit |> residuals() |> abs() |> mean()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2.341\n```\n\n\n:::\n:::\n\n\n\nNote, contudo, que a situação fica um pouco mais complicada no caso em que se quer calcular a raiz do erro quadrado médio.\n\n$$\n\\text{REQM} = \\sqrt{\\frac{1}{N}\\sum_{i = 1}^{N}(e_{i})^2}\n$$\n\nNa sintaxe convencional temos\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsqrt(mean(residuals(fit)^2))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2.949\n```\n\n\n:::\n:::\n\n\n\nO problema é que a exponenciação acontece via um *operador* e não uma *função convencional*. Nenhum dos exemplos abaixo funciona.\n\n::: content-margin\nUm *operador*, na verdade, é um tipo especial de função. Operadores aritméticos são o caso mais comum (+, -, \\*, etc.), mas há vários outros tipos de operadores especiais dentro do R. O próprio pipe é um operador.\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfit |> residuals() |> ^2 |> mean() |> sqrt()\n```\n\n::: {.cell-output .cell-output-error}\n\n```\nError in parse(text = input): <text>:1:23: unexpected '^'\n1: fit |> residuals() |> ^\n                          ^\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nfit |> residuals()^2 |> mean() |> sqrt()\n```\n\n::: {.cell-output .cell-output-error}\n\n```\nError in residuals()^2: function '^' not supported in RHS call of a pipe (<input>:1:8)\n```\n\n\n:::\n:::\n\n\n\nPara chegar no mesmo resultado, novamente precisa-se usar uma sintaxe bastante esotérica que envolve passar o resultado de `residuals` para uma função anônima.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# eval: false\nfit |> residuals() |> (\\(y) {sqrt(mean(y^2))})()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2.949\n```\n\n\n:::\n:::\n\n\n\nAlternativamente, podemos criar uma função e preservar a lógica original do pipe.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# eval: false\nelevar_quadrado <- function(x) { x^2 }\nfit |> residuals() |> elevar_quadrado() |> mean() |> sqrt()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2.949\n```\n\n\n:::\n:::\n\n\n\n## Resumo\n\nAssim, apesar de muito útil, o operador pipe tem suas limitações. O operador sempre espera encontrar uma função à sua direita; a única maneira de seguir `|>` com um operador é criando uma função anônima, cuja sintaxe é um pouco carregada. Pode-se resumir os principais fatos sobre o operador pipe:\n\n1.  *Simplifica funções compostas*. Na expressão `x |> f |> g` o operador `|>` aplica a função `f` sobre o objeto `x` usando `x` como argumento de `f`. Depois, aplica a função `g` sobre o resultado de `f(x)`. Isto é equivalente a `g(f(x))`.\n2.  *Evita a definição de objetos intermediários*. O uso de pipes evita que você precise \"salvar\" cada passo intermediário da aplicação de funções. Isto deixa seu espaço de trabalho mais limpo e também consome menos memória.\n3.  *Placeholder*. Quando o objeto anterior não serve como o primeiro argumento da função subsequente, usa-se o placeholder para indicar onde ele deve ser inserido. `x |> f(y = 2, data = _)`.\n4.  *Função anônima*. Em casos mais complexos, é necessário montar uma função anônima usando `x |> (\\(y) {funcao})()`.\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}